<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>SwipeRefreshLayout源码分析 | itgoyo技术栈</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">SwipeRefreshLayout源码分析</h1><a id="logo" href="/.">itgoyo技术栈</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 主页</i></a><a href="/archives/"><i class="fa fa-archive"> 文章</i></a><a href="http://kotlinandroid.net/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">SwipeRefreshLayout源码分析</h1><div class="post-meta">Jul 26, 2017<span> | </span><span class="category"><a href="/categories/源码分析/">源码分析</a></span></div><div class="post-content"><p><img src="https://img.shields.io/github/stars/itgoyo/AndroidSource-Analysis.svg?style=social&amp;label=Star" alt=""></p>
<p>项目地址： <a href="https://github.com/itgoyo/AndroidSource-Analysis">https://github.com/itgoyo/AndroidSource-Analysis</a></p>
<p>简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="http://developer.android.com/intl/zh-cn/reference/android/support/v4/widget/SwipeRefreshLayout.html" target="_blank" rel="noopener">官方文档</a></p>
<p><code>SwipeRefreshLayout</code> 是一个下拉刷新控件，几乎可以包裹一个任何可以滚动的内容（ListView GridView ScrollView RecyclerView），可以自动识别垂直滚动手势。使用起来非常方便。</p>
<p><img src="images/SwipeRefreshLayout1" alt=""> <img src="images/SwipeRefreshLayout2" alt=""></p>
<p> 1.将需要下拉刷新的空间包裹起来</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">android.support.v4.widget.SwipeRefreshLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/recyclerView"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">android.support.v4.widget.SwipeRefreshLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 2.设置刷新动画的触发回调</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置下拉出现小圆圈是否是缩放出现，出现的位置，最大的下拉位置</span></span><br><span class="line">mySwipeRefreshLayout.setProgressViewOffset(<span class="keyword">true</span>, <span class="number">50</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置下拉圆圈的大小，两个值 LARGE， DEFAULT</span></span><br><span class="line">mySwipeRefreshLayout.setSize(SwipeRefreshLayout.LARGE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置下拉圆圈上的颜色，蓝色、绿色、橙色、红色</span></span><br><span class="line">mySwipeRefreshLayout.setColorSchemeResources(</span><br><span class="line">    android.R.color.holo_blue_bright,</span><br><span class="line">    android.R.color.holo_green_light,</span><br><span class="line">    android.R.color.holo_orange_light,</span><br><span class="line">    android.R.color.holo_red_light);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 setEnabled(false) 禁用下拉刷新</span></span><br><span class="line">mySwipeRefreshLayout.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定下拉圆圈的背景</span></span><br><span class="line">mSwipeLayout.setProgressBackgroundColor(R.color.red);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置手势下拉刷新的监听</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mySwipeRefreshLayout.setOnRefreshListener(</span><br><span class="line">    <span class="keyword">new</span> SwipeRefreshLayout.OnRefreshListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 刷新动画开始后回调到此方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>通过 <code>setRefreshing(false)</code> 和 <code>setRefreshing(true)</code> 来手动调用刷新的动画。</p>
<blockquote>
<p><code>onRefresh</code> 的回调只有在手势下拉的情况下才会触发，通过 <code>setRefreshing</code> 只能调用刷新的动画是否显示。<br>SwipeRefreshLayout 也可放在 CoordinatorLayout 内共同处理滑动冲突，有兴趣可以尝试。</p>
</blockquote>
<h2 id="SwipeRefreshLayout-源码分析"><a href="#SwipeRefreshLayout-源码分析" class="headerlink" title="SwipeRefreshLayout 源码分析"></a>SwipeRefreshLayout 源码分析</h2><blockquote>
<p>本文基于 v4 版本 <code>23.2.0</code></p>
</blockquote>
<p>extends <code>ViewGroup</code> implements <code>NestedScrollingParent</code> <code>NestedScrollingChild</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object</span><br><span class="line">   ↳	android.view.View</span><br><span class="line"> 	   ↳	android.view.ViewGroup</span><br><span class="line"> 	 	   ↳	android.support.v4.widget.SwipeRefreshLayout</span><br></pre></td></tr></table></figure></p>
<p>SwipeRefreshLayout 的分析分为两个部分：<strong>自定义 ViewGroup 的部分</strong>，<strong>处理和子视图的嵌套滚动部分</strong>。</p>
<h3 id="SwipeRefreshLayout-extends-ViewGroup"><a href="#SwipeRefreshLayout-extends-ViewGroup" class="headerlink" title="SwipeRefreshLayout extends ViewGroup"></a>SwipeRefreshLayout extends ViewGroup</h3><p>其实就是一个自定义的 ViewGroup ，结合我们自己平时自定义 ViewGroup 的步骤：</p>
<ol>
<li>初始化变量</li>
<li>onMeasure</li>
<li>onLayout</li>
<li>处理交互 （<code>dispatchTouchEvent</code> <code>onInterceptTouchEvent</code> <code>onTouchEvent</code>）</li>
</ol>
<p>接下来就按照上面的步骤进行分析。</p>
<h4 id="1-初始化变量"><a href="#1-初始化变量" class="headerlink" title="1.初始化变量"></a>1.初始化变量</h4><p><code>SwipeRefreshLayout</code> 内部有 2 个 View，一个<code>圆圈（mCircleView）</code>，一个内部可滚动的<code>View（mTarget）</code>。除了 View，还包含一个 <code>OnRefreshListener</code> 接口，当刷新动画被触发时回调。</p>
<p> <img src="https://dn-coding-net-production-pp.qbox.me/8e02212d-b364-4df8-bfaa-47f3084f89e7.png" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor that is called when inflating SwipeRefreshLayout from XML.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> attrs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SwipeRefreshLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统默认的最小滚动距离</span></span><br><span class="line">    mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 系统默认的动画时长</span></span><br><span class="line">    mMediumAnimationDuration = getResources().getInteger(</span><br><span class="line">            android.R.integer.config_mediumAnimTime);</span><br><span class="line"></span><br><span class="line">    setWillNotDraw(<span class="keyword">false</span>);</span><br><span class="line">    mDecelerateInterpolator = <span class="keyword">new</span> DecelerateInterpolator(DECELERATE_INTERPOLATION_FACTOR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 xml 中定义的属性</span></span><br><span class="line">    <span class="keyword">final</span> TypedArray a = context.obtainStyledAttributes(attrs, LAYOUT_ATTRS);</span><br><span class="line">    setEnabled(a.getBoolean(<span class="number">0</span>, <span class="keyword">true</span>));</span><br><span class="line">    a.recycle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新的圆圈的大小，单位转换成 sp</span></span><br><span class="line">    <span class="keyword">final</span> DisplayMetrics metrics = getResources().getDisplayMetrics();</span><br><span class="line">    mCircleWidth = (<span class="keyword">int</span>) (CIRCLE_DIAMETER * metrics.density);</span><br><span class="line">    mCircleHeight = (<span class="keyword">int</span>) (CIRCLE_DIAMETER * metrics.density);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建刷新动画的圆圈</span></span><br><span class="line">    createProgressView();</span><br><span class="line"></span><br><span class="line">    ViewCompat.setChildrenDrawingOrderEnabled(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// the absolute offset has to take into account that the circle starts at an offset</span></span><br><span class="line">    mSpinnerFinalOffset = DEFAULT_CIRCLE_TARGET * metrics.density;</span><br><span class="line">    <span class="comment">// 刷新动画的临界距离值</span></span><br><span class="line">    mTotalDragDistance = mSpinnerFinalOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 NestedScrolling 机制来处理嵌套滚动</span></span><br><span class="line">    mNestedScrollingParentHelper = <span class="keyword">new</span> NestedScrollingParentHelper(<span class="keyword">this</span>);</span><br><span class="line">    mNestedScrollingChildHelper = <span class="keyword">new</span> NestedScrollingChildHelper(<span class="keyword">this</span>);</span><br><span class="line">    setNestedScrollingEnabled(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// 创建刷新动画的圆圈<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createProgressView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mCircleView = <span class="keyword">new</span> CircleImageView(getContext(), CIRCLE_BG_LIGHT, CIRCLE_DIAMETER/<span class="number">2</span>);</span><br><span class="line">    mProgress = <span class="keyword">new</span> MaterialProgressDrawable(getContext(), <span class="keyword">this</span>);</span><br><span class="line">    mProgress.setBackgroundColor(CIRCLE_BG_LIGHT);</span><br><span class="line">    mCircleView.setImageDrawable(mProgress);</span><br><span class="line">    mCircleView.setVisibility(View.GONE);</span><br><span class="line">    addView(mCircleView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化的时候创建一个出来一个 View （下拉刷新的圆圈）。可以看出使用背景圆圈是 v4 包里提供的 <code>CircleImageView</code> 控件，中间的是 <code>MaterialProgressDrawable</code> 进度条。<br>另一个 View 是在 xml 中包含的可滚动视图。</p>
<h4 id="2-onMeasure"><a href="#2-onMeasure" class="headerlink" title="2.onMeasure"></a>2.onMeasure</h4><p>onMeasure 确定子视图的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (mTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 确定内部要滚动的View，如 RecycleView</span></span><br><span class="line">        ensureTarget();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测量子 View （mTarget）</span></span><br><span class="line">    mTarget.measure(MeasureSpec.makeMeasureSpec(</span><br><span class="line">            getMeasuredWidth() - getPaddingLeft() - getPaddingRight(),</span><br><span class="line">            MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(</span><br><span class="line">            getMeasuredHeight() - getPaddingTop() - getPaddingBottom(), MeasureSpec.EXACTLY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测量刷新的圆圈 mCircleView</span></span><br><span class="line">    mCircleView.measure(MeasureSpec.makeMeasureSpec(mCircleWidth, MeasureSpec.EXACTLY),</span><br><span class="line">            MeasureSpec.makeMeasureSpec(mCircleHeight, MeasureSpec.EXACTLY));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mUsingCustomStart &amp;&amp; !mOriginalOffsetCalculated) &#123;</span><br><span class="line">        mOriginalOffsetCalculated = <span class="keyword">true</span>;</span><br><span class="line">        mCurrentTargetOffsetTop = mOriginalOffsetTop = -mCircleView.getMeasuredHeight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 mCircleView 在 ViewGroup 中的索引</span></span><br><span class="line">    mCircleViewIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Get the index of the circleview.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; getChildCount(); index++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getChildAt(index) == mCircleView) &#123;</span><br><span class="line">            mCircleViewIndex = index;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个步骤确定了 mCircleView 和 SwipeRefreshLayout 的子视图的大小。</p>
<h4 id="3-onLayout"><a href="#3-onLayout" class="headerlink" title="3.onLayout"></a>3.onLayout</h4><p>onLayout 主要负责确定各个子视图的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 获取 SwipeRefreshLayout 的宽高</span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> width = getMeasuredWidth();</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> height = getMeasuredHeight();</span><br><span class="line">   <span class="keyword">if</span> (getChildCount() == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (mTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">       ensureTarget();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (mTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 考虑到给控件设置 padding，去除 padding 的距离</span></span><br><span class="line">   <span class="keyword">final</span> View child = mTarget;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> childLeft = getPaddingLeft();</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> childTop = getPaddingTop();</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> childWidth = width - getPaddingLeft() - getPaddingRight();</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> childHeight = height - getPaddingTop() - getPaddingBottom();</span><br><span class="line">   <span class="comment">// 设置 mTarget 的位置</span></span><br><span class="line">   child.layout(childLeft, childTop, childLeft + childWidth, childTop + childHeight);</span><br><span class="line">   <span class="keyword">int</span> circleWidth = mCircleView.getMeasuredWidth();</span><br><span class="line">   <span class="keyword">int</span> circleHeight = mCircleView.getMeasuredHeight();</span><br><span class="line">   <span class="comment">// 根据 mCurrentTargetOffsetTop 变量的值来设置 mCircleView 的位置</span></span><br><span class="line">   mCircleView.layout((width / <span class="number">2</span> - circleWidth / <span class="number">2</span>), mCurrentTargetOffsetTop,</span><br><span class="line">           (width / <span class="number">2</span> + circleWidth / <span class="number">2</span>), mCurrentTargetOffsetTop + circleHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="https://dn-coding-net-production-pp.qbox.me/8df6d458-700b-4ec5-b731-c6b8c34cdddc.png" alt="图片"></p>
<p>在 onLayout 中放置了 mCircleView 的位置，注意 顶部位置是 mCurrentTargetOffsetTop ，mCurrentTargetOffsetTop 初始距离是<code>-mCircleView.getMeasuredHeight()</code>，所以是在 SwipeRefreshLayout 外。</p>
<blockquote>
<p>经过以上几个步骤，SwipeRefreshLayout 创建了子视图，确定他们的大小、位置，现在所有视图可以显示在界面了。</p>
</blockquote>
<h3 id="处理与子视图的滚动交互"><a href="#处理与子视图的滚动交互" class="headerlink" title="处理与子视图的滚动交互"></a>处理与子视图的滚动交互</h3><p>下拉刷新控件的主要功能是当子视图下拉到最顶部时，继续下拉可以出现刷新动画。而子视图可以滚动时需要将所有滚动事件都交给子视图。借助 Android 提供的 NestedScrolling 机制，使得 SwipeRefreshLayout 很轻松的解决了与子视图的滚动冲突问题。<br>SwipeRefreshLayout 通过实现 <code>NestedScrollingParent</code> 和 <code>NestedScrollingChild</code> 接口来处理滚动冲突。SwipeRefreshLayout 作为 Parent 嵌套一个可以滚动的子视图，那么就需要了解一下 NestedScrollingParent 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 当你希望自己的自定义布局支持嵌套子视图并且处理滚动操作，就可以实现该接口。</span></span><br><span class="line"><span class="comment"> 实现这个接口后可以创建一个 NestedScrollingParentHelper 字段，使用它来帮助你处理大部分的方法。</span></span><br><span class="line"><span class="comment"> 处理嵌套的滚动时应该使用  `ViewCompat`，`ViewGroupCompat`或`ViewParentCompat` 中的方法来处理，这是一些兼容库，</span></span><br><span class="line"><span class="comment"> 他们保证 Android 5.0之前的兼容性垫片的静态方法，这样可以兼容 Android 5.0 之前的版本。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollingParent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当子视图调用 startNestedScroll(View, int) 后调用该方法。返回 true 表示响应子视图的滚动。</span></span><br><span class="line"><span class="comment">     * 实现这个方法来声明支持嵌套滚动，如果返回 true，那么这个视图将要配合子视图嵌套滚动。当嵌套滚动结束时会调用到 onStopNestedScroll(View)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child 可滚动的子视图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target NestedScrollingParent 的直接可滚动的视图，一般情况就是 child</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nestedScrollAxes 包含 ViewCompat#SCROLL_AXIS_HORIZONTAL, ViewCompat#SCROLL_AXIS_VERTICAL 或者两个值都有。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 true 表示响应子视图的滚动。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果 onStartNestedScroll 返回 true ，然后走该方法，这个方法里可以做一些初始化。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子视图开始滚动前会调用这个方法。这时候父布局（也就是当前的 NestedScrollingParent 的实现类）可以通过这个方法来配合子视图同时处理滚动事件。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 滚动的子视图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dx 绝对值为手指在x方向滚动的距离，dx&lt;0 表示手指在屏幕向右滚动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dy 绝对值为手指在y方向滚动的距离，dy&lt;0 表示手指在屏幕向下滚动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumed 一个数组，值用来表示父布局消耗了多少距离，未消耗前为[0,0], 如果父布局想处理滚动事件，就可以在这个方法的实现中为consumed[0]，consumed[1]赋值。</span></span><br><span class="line"><span class="comment">     *                 分别表示x和y方向消耗的距离。如父布局想在竖直方向（y）完全拦截子视图，那么让 consumed[1] = dy，就把手指产生的触摸事件给拦截了，子视图便响应不到触摸事件了 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法表示子视图正在滚动，并且把滚动距离回调用到该方法，前提是 onStartNestedScroll 返回了 true。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Both the consumed and unconsumed portions of the scroll distance are reported to the</span></span><br><span class="line"><span class="comment">     * ViewParent. An implementation may choose to use the consumed portion to match or chase scroll</span></span><br><span class="line"><span class="comment">     * position of multiple child elements, for example. The unconsumed portion may be used to</span></span><br><span class="line"><span class="comment">     * allow continuous dragging of multiple scrolling or draggable elements, such as scrolling</span></span><br><span class="line"><span class="comment">     * a list within a vertical drawer where the drawer begins dragging once the edge of inner</span></span><br><span class="line"><span class="comment">     * scrolling content is reached.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 滚动的子视图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dxConsumed 手指产生的触摸距离中，子视图消耗的x方向的距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dyConsumed 手指产生的触摸距离中，子视图消耗的y方向的距离 ，如果 onNestedPreScroll 中 dy = 20， consumed[0] = 8，那么 dy = 12</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> dxUnconsumed 手指产生的触摸距离中，未被子视图消耗的x方向的距离</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dyUnconsumed 手指产生的触摸距离中，未被子视图消耗的y方向的距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,<span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应嵌套滚动结束</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当一个嵌套滚动结束后（如MotionEvent#ACTION_UP， MotionEvent#ACTION_CANCEL）会调用该方法，在这里可有做一些收尾工作，比如变量重置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStopNestedScroll</span><span class="params">(View target)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手指在屏幕快速滑触发Fling前回调，如果前面 onNestedPreScroll 中父布局消耗了事件，那么这个也会被触发</span></span><br><span class="line"><span class="comment">     * 返回true表示父布局完全处理 fling 事件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 滚动的子视图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> velocityX x方向的速度（px/s）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> velocityY y方向的速度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if this parent consumed the fling ahead of the target view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNestedPreFling</span><span class="params">(View target, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子视图fling 时回调，父布局可以选择监听子视图的 fling。</span></span><br><span class="line"><span class="comment">     * true 表示父布局处理 fling，false表示父布局监听子视图的fling</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target View that initiated the nested scroll</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> velocityX Horizontal velocity in pixels per second</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> velocityY Vertical velocity in pixels per second</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumed true 表示子视图处理了fling</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onNestedFling</span><span class="params">(View target, <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY, <span class="keyword">boolean</span> consumed)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前 NestedScrollingParent 的滚动方向，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ViewCompat#SCROLL_AXIS_HORIZONTAL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ViewCompat#SCROLL_AXIS_VERTICAL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ViewCompat#SCROLL_AXIS_NONE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNestedScrollAxes</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下 SwipeRefreshLayout 实现 NestedScrollingParent 的相关方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NestedScrollingParent</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子 View （NestedScrollingChild）开始滚动前回调此方法,返回 true 表示接 Parent 收嵌套滚动，然后调用 onNestedScrollAccepted</span></span><br><span class="line"><span class="comment">// 具体可以看 NestedScrollingChildHelper 的源码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子 View 回调，判断是否开始嵌套滚动 ，</span></span><br><span class="line">    <span class="keyword">return</span> isEnabled() &amp;&amp; !mReturningToStart &amp;&amp; !mRefreshing</span><br><span class="line">            &amp;&amp; (nestedScrollAxes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(View child, View target, <span class="keyword">int</span> axes)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Reset the counter of how much leftover scroll needs to be consumed.</span></span><br><span class="line">     mNestedScrollingParentHelper.onNestedScrollAccepted(child, target, axes);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// ...省略代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>SwipeRefreshLayout 只接受竖直方向（Y轴）的滚动，并且在刷新动画进行中不接受滚动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NestedScrollingChild 在滚动的时候会触发， 看父类消耗了多少距离</span></span><br><span class="line"><span class="comment">//   * @param dx x 轴滚动的距离</span></span><br><span class="line"><span class="comment">//   * @param dy y 轴滚动的距离</span></span><br><span class="line"><span class="comment">//   * @param consumed 代表 父 View 消费的滚动距离</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dy &gt; 0 表示手指在屏幕向上移动</span></span><br><span class="line">    <span class="comment">//  mTotalUnconsumed 表示子视图Y轴未消费的距离</span></span><br><span class="line">    <span class="comment">// 现在表示</span></span><br><span class="line">    <span class="keyword">if</span> (dy &gt; <span class="number">0</span> &amp;&amp; mTotalUnconsumed &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dy &gt; mTotalUnconsumed) &#123;</span><br><span class="line">            consumed[<span class="number">1</span>] = dy - (<span class="keyword">int</span>) mTotalUnconsumed; <span class="comment">// SwipeRefreshLayout 就吧子视图位消费的距离全部消费了。</span></span><br><span class="line">            mTotalUnconsumed = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mTotalUnconsumed -= dy; <span class="comment">// 消费的 y 轴的距离</span></span><br><span class="line">            consumed[<span class="number">1</span>] = dy;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 出现动画圆圈，并向上移动</span></span><br><span class="line">        moveSpinner(mTotalUnconsumed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// onStartNestedScroll 返回 true 才会调用此方法。此方法表示子View将滚动事件分发到父 View（SwipeRefreshLayout）</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(<span class="keyword">final</span> View target, <span class="keyword">final</span> <span class="keyword">int</span> dxConsumed, <span class="keyword">final</span> <span class="keyword">int</span> dyConsumed,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> dxUnconsumed, <span class="keyword">final</span> <span class="keyword">int</span> dyUnconsumed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 省略代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is a bit of a hack. Nested scrolling works from the bottom up, and as we are</span></span><br><span class="line">    <span class="comment">// sometimes between two nested scrolling views, we need a way to be able to know when any</span></span><br><span class="line">    <span class="comment">// nested scrolling parent has stopped handling events. We do that by using the</span></span><br><span class="line">    <span class="comment">// 'offset in window 'functionality to see if we have been moved from the event.</span></span><br><span class="line">    <span class="comment">// This is a decent indication of whether we should take over the event stream or not.</span></span><br><span class="line">    <span class="comment">// 手指在屏幕上向下滚动，并且子视图不可以滚动</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dy = dyUnconsumed + mParentOffsetInWindow[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (dy &lt; <span class="number">0</span> &amp;&amp; !canChildScrollUp()) &#123;</span><br><span class="line">        mTotalUnconsumed += Math.abs(dy);</span><br><span class="line">        moveSpinner(mTotalUnconsumed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SwipeRefreshLayout 通过 NestedScrollingParent 接口完成了处理子视图的滚动的冲突，中间省略了一些 SwipeRefreshLayout作为 child 的相关代码，这种情况是为了兼容将 SwipeRefreshLayout 作为子视图放在知识嵌套滚动的父布局的情况，这里不做深入讨论。但是下拉刷新需要判断手指在屏幕的状态来进行一个刷新的动画，所以我们还需要处理触摸事件，判断手指在屏幕中的状态。</p>
<p>首先是 onInterceptTouchEvent，返回 true 表示拦截触摸事件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    ensureTarget();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 手指按下时恢复状态</span></span><br><span class="line">    <span class="keyword">if</span> (mReturningToStart &amp;&amp; action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        mReturningToStart = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控件可用 || 刷新事件刚结束正在恢复初始状态时 || 子 View 可滚动 || 正在刷新 || 父 View 正在滚动</span></span><br><span class="line">    <span class="keyword">if</span> (!isEnabled() || mReturningToStart || canChildScrollUp()</span><br><span class="line">            || mRefreshing || mNestedScrollInProgress) &#123;</span><br><span class="line">        <span class="comment">// Fail fast if we're not in a state where a swipe is possible</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            setTargetOffsetTopAndBottom(mOriginalOffsetTop - mCircleView.getTop(), <span class="keyword">true</span>);</span><br><span class="line">            mActivePointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);</span><br><span class="line">            mIsBeingDragged = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 记录手指按下的位置，为了判断是否开始滚动</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> initialDownY = getMotionEventY(ev, mActivePointerId);</span><br><span class="line">            <span class="keyword">if</span> (initialDownY == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mInitialDownY = initialDownY;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">if</span> (mActivePointerId == INVALID_POINTER) &#123;</span><br><span class="line">                Log.e(LOG_TAG, <span class="string">"Got ACTION_MOVE event but don't have an active pointer id."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y = getMotionEventY(ev, mActivePointerId);</span><br><span class="line">            <span class="keyword">if</span> (y == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断当拖动距离大于最小距离时设置 mIsBeingDragged = true;</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> yDiff = y - mInitialDownY;</span><br><span class="line">            <span class="keyword">if</span> (yDiff &gt; mTouchSlop &amp;&amp; !mIsBeingDragged) &#123;</span><br><span class="line">                mInitialMotionY = mInitialDownY + mTouchSlop;</span><br><span class="line">                mIsBeingDragged = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 正在拖动状态，更新圆圈的 progressbar 的 alpha 值</span></span><br><span class="line">                mProgress.setAlpha(STARTING_PROGRESS_ALPHA);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEventCompat.ACTION_POINTER_UP:</span><br><span class="line">            onSecondaryPointerUp(ev);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">            mIsBeingDragged = <span class="keyword">false</span>;</span><br><span class="line">            mActivePointerId = INVALID_POINTER;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mIsBeingDragged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到源码也就是进行简单处理，DOWN 的时候记录一下位置，MOVE 时判断移动的距离，返回值 mIsBeingDragged 为 true 时， 即 onInterceptTouchEvent 返回true，SwipeRefreshLayout 拦截触摸事件，不分发给 mTarget，然后把 MotionEvent 传给 onTouchEvent 方法。其中有一个判断子View的是否还可以滚动的方法 <code>canChildScrollUp</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Whether it is possible for the child view of this layout to</span></span><br><span class="line"><span class="comment"> *         scroll up. Override this if the child view is a custom view.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canChildScrollUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &lt; <span class="number">14</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断 AbsListView 的子类 ListView 或者 GridView 等</span></span><br><span class="line">        <span class="keyword">if</span> (mTarget <span class="keyword">instanceof</span> AbsListView) &#123;</span><br><span class="line">            <span class="keyword">final</span> AbsListView absListView = (AbsListView) mTarget;</span><br><span class="line">            <span class="keyword">return</span> absListView.getChildCount() &gt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (absListView.getFirstVisiblePosition() &gt; <span class="number">0</span> || absListView.getChildAt(<span class="number">0</span>)</span><br><span class="line">                            .getTop() &lt; absListView.getPaddingTop());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ViewCompat.canScrollVertically(mTarget, -<span class="number">1</span>) || mTarget.getScrollY() &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ViewCompat.canScrollVertically(mTarget, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当SwipeRefreshLayout 拦截了触摸事件之后（ mIsBeingDragged 为 true ），将 MotionEvent 交给 onTouchEvent 处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略代码</span></span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 获取第一个按下的手指</span></span><br><span class="line">            mActivePointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);</span><br><span class="line">            mIsBeingDragged = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            <span class="comment">// 处理多指触控</span></span><br><span class="line">            pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ... 省略代码</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, pointerIndex);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> overscrollTop = (y - mInitialMotionY) * DRAG_RATE;</span><br><span class="line">            <span class="keyword">if</span> (mIsBeingDragged) &#123;</span><br><span class="line">                <span class="keyword">if</span> (overscrollTop &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 正在拖动状态，更新圆圈的位置</span></span><br><span class="line">                    moveSpinner(overscrollTop);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... 省略代码</span></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">            pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId);</span><br><span class="line">            <span class="keyword">if</span> (pointerIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Log.e(LOG_TAG, <span class="string">"Got ACTION_UP event but don't have an active pointer id."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, pointerIndex);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> overscrollTop = (y - mInitialMotionY) * DRAG_RATE;</span><br><span class="line">            mIsBeingDragged = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 手指松开，将圆圈移动到正确的位置</span></span><br><span class="line">            finishSpinner(overscrollTop);</span><br><span class="line">            mActivePointerId = INVALID_POINTER;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... 省略代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在手指滚动过程中通过判断 mIsBeingDragged 来移动刷新的圆圈（对应的是 moveSpinner ），手指松开将圆圈移动到正确位置（初始位置或者刷新动画的位置，对应的是 finishSpinner 方法）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手指下拉过程中触发的圆圈的变化过程，透明度变化，渐渐出现箭头，大小的变化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveSpinner</span><span class="params">(<span class="keyword">float</span> overscrollTop)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为有箭头的 progress</span></span><br><span class="line">    mProgress.showArrow(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进度转化成百分比</span></span><br><span class="line">    <span class="keyword">float</span> originalDragPercent = overscrollTop / mTotalDragDistance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 避免百分比超过 100%</span></span><br><span class="line">    <span class="keyword">float</span> dragPercent = Math.min(<span class="number">1f</span>, Math.abs(originalDragPercent));</span><br><span class="line">    <span class="comment">// 调整拖动百分比，造成视差效果</span></span><br><span class="line">    <span class="keyword">float</span> adjustedPercent = (<span class="keyword">float</span>) Math.max(dragPercent - .<span class="number">4</span>, <span class="number">0</span>) * <span class="number">5</span> / <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">float</span> extraOS = Math.abs(overscrollTop) - mTotalDragDistance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里mUsingCustomStart 为 true 代表用户自定义了起始出现的坐标</span></span><br><span class="line">    <span class="keyword">float</span> slingshotDist = mUsingCustomStart ? mSpinnerFinalOffset - mOriginalOffsetTop</span><br><span class="line">            : mSpinnerFinalOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 弹性系数</span></span><br><span class="line">    <span class="keyword">float</span> tensionSlingshotPercent = Math.max(<span class="number">0</span>, Math.min(extraOS, slingshotDist * <span class="number">2</span>)</span><br><span class="line">            / slingshotDist);</span><br><span class="line">    <span class="keyword">float</span> tensionPercent = (<span class="keyword">float</span>) ((tensionSlingshotPercent / <span class="number">4</span>) - Math.pow(</span><br><span class="line">            (tensionSlingshotPercent / <span class="number">4</span>), <span class="number">2</span>)) * <span class="number">2f</span>;</span><br><span class="line">    <span class="keyword">float</span> extraMove = (slingshotDist) * tensionPercent * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为有弹性系数，不同的手指滚动距离不同于view的移动距离</span></span><br><span class="line">    <span class="keyword">int</span> targetY = mOriginalOffsetTop + (<span class="keyword">int</span>) ((slingshotDist * dragPercent) + extraMove);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// where 1.0f is a full circle</span></span><br><span class="line">    <span class="keyword">if</span> (mCircleView.getVisibility() != View.VISIBLE) &#123;</span><br><span class="line">        mCircleView.setVisibility(View.VISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置的是否有缩放</span></span><br><span class="line">    <span class="keyword">if</span> (!mScale) &#123;</span><br><span class="line">        ViewCompat.setScaleX(mCircleView, <span class="number">1f</span>);</span><br><span class="line">        ViewCompat.setScaleY(mCircleView, <span class="number">1f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置缩放进度</span></span><br><span class="line">    <span class="keyword">if</span> (mScale) &#123;</span><br><span class="line">        setAnimationProgress(Math.min(<span class="number">1f</span>, overscrollTop / mTotalDragDistance));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动距离未达到最大距离</span></span><br><span class="line">    <span class="keyword">if</span> (overscrollTop &lt; mTotalDragDistance) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mProgress.getAlpha() &gt; STARTING_PROGRESS_ALPHA</span><br><span class="line">                &amp;&amp; !isAnimationRunning(mAlphaStartAnimation)) &#123;</span><br><span class="line">            <span class="comment">// Animate the alpha</span></span><br><span class="line">            startProgressAlphaStartAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mProgress.getAlpha() &lt; MAX_ALPHA &amp;&amp; !isAnimationRunning(mAlphaMaxAnimation)) &#123;</span><br><span class="line">            <span class="comment">// Animate the alpha</span></span><br><span class="line">            startProgressAlphaMaxAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出现的进度，裁剪 mProgress</span></span><br><span class="line">    <span class="keyword">float</span> strokeStart = adjustedPercent * .<span class="number">8f</span>;</span><br><span class="line">    mProgress.setStartEndTrim(<span class="number">0f</span>, Math.min(MAX_PROGRESS_ANGLE, strokeStart));</span><br><span class="line">    mProgress.setArrowScale(Math.min(<span class="number">1f</span>, adjustedPercent));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 旋转</span></span><br><span class="line">    <span class="keyword">float</span> rotation = (-<span class="number">0.25f</span> + .<span class="number">4f</span> * adjustedPercent + tensionPercent * <span class="number">2</span>) * .<span class="number">5f</span>;</span><br><span class="line">    mProgress.setProgressRotation(rotation);</span><br><span class="line">    setTargetOffsetTopAndBottom(targetY - mCurrentTargetOffsetTop, <span class="keyword">true</span> <span class="comment">/* requires update */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷新圆圈的移动过程也是有好几种状态，看上面的注释基本上就比较清楚了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishSpinner</span><span class="params">(<span class="keyword">float</span> overscrollTop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (overscrollTop &gt; mTotalDragDistance) &#123;</span><br><span class="line">        <span class="comment">//移动距离超过了刷新的临界值，触发刷新动画</span></span><br><span class="line">        setRefreshing(<span class="keyword">true</span>, <span class="keyword">true</span> <span class="comment">/* notify */</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 取消刷新的圆圈，将圆圈移动到初始位置</span></span><br><span class="line">        mRefreshing = <span class="keyword">false</span>;</span><br><span class="line">        mProgress.setStartEndTrim(<span class="number">0f</span>, <span class="number">0f</span>);</span><br><span class="line">        <span class="comment">// ...省略代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到初始位置</span></span><br><span class="line">        animateOffsetToStartPosition(mCurrentTargetOffsetTop, listener);</span><br><span class="line">        <span class="comment">// 设置没有箭头</span></span><br><span class="line">        mProgress.showArrow(<span class="keyword">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到调用 setRefresh(true,true) 方法触发刷新动画并进行回调，但是这个方法是 private 的。前面提到我们自己调用 setRefresh(true) 只能产生动画，而不能回调刷新函数，那么我们就可以用反射调用 2 个参数的 setRefresh 函数。 或者手动调 setRefreshing(true)+ OnRefreshListener.onRefresh 方法。</p>
<h3 id="setRefresh"><a href="#setRefresh" class="headerlink" title="setRefresh"></a>setRefresh</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 改变刷新动画的的圆圈刷新状态。Notify the widget that refresh state has changed. Do not call this when</span></span><br><span class="line"><span class="comment">  * refresh is triggered by a swipe gesture.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> refreshing 是否显示刷新的圆圈</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRefreshing</span><span class="params">(<span class="keyword">boolean</span> refreshing)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (refreshing &amp;&amp; mRefreshing != refreshing) &#123;</span><br><span class="line">         <span class="comment">// scale and show</span></span><br><span class="line">         mRefreshing = refreshing;</span><br><span class="line">         <span class="keyword">int</span> endTarget = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">if</span> (!mUsingCustomStart) &#123;</span><br><span class="line">             endTarget = (<span class="keyword">int</span>) (mSpinnerFinalOffset + mOriginalOffsetTop);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             endTarget = (<span class="keyword">int</span>) mSpinnerFinalOffset;</span><br><span class="line">         &#125;</span><br><span class="line">         setTargetOffsetTopAndBottom(endTarget - mCurrentTargetOffsetTop,</span><br><span class="line">                 <span class="keyword">true</span> <span class="comment">/* requires update */</span>);</span><br><span class="line">         mNotify = <span class="keyword">false</span>;</span><br><span class="line">         startScaleUpAnimation(mRefreshListener);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         setRefreshing(refreshing, <span class="keyword">false</span> <span class="comment">/* notify */</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>startScaleUpAnimation 开启一个动画，然后在动画结束后回调 onRefresh 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Animation.AnimationListener mRefreshListener = <span class="keyword">new</span> Animation.AnimationListener() &#123;</span><br><span class="line">   <span class="comment">// .. 省略代码</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mRefreshing) &#123;</span><br><span class="line">           mProgress.setAlpha(MAX_ALPHA); <span class="comment">//确保刷新圆圈中间的进度条是完全不透明了</span></span><br><span class="line">           mProgress.start();</span><br><span class="line">           <span class="keyword">if</span> (mNotify) &#123; <span class="comment">// 当 mNotify 为 true 时才会回调 onRefresh</span></span><br><span class="line">               <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="comment">// 回调 listener 的 onRefresh 方法</span></span><br><span class="line">                   mListener.onRefresh();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           mCurrentTargetOffsetTop = mCircleView.getTop();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           reset();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分析 SwipeRefreshLayout 的流程就是按照平时我们自定义 <code>ViewGroup</code> 的流程，但是其中也有好多需要我们借鉴的地方，如何使用 NestedScrolling相关机制 ，多点触控的处理，onMeasure 中减去了 padding，如何判断子 View 是否可滚动，如何确定 ViewGroup 中某一个 View 的索引等。<br>此外，一个好的下拉刷新框架不仅仅要兼容各种滚动的子控件，还要考虑自己要兼容 NestedScrollingChild 的情况，比如放到 CooCoordinatorLayout 的情况，目前大多数开源的下拉刷新好像都没有达到这个要求，一般都是只考虑了内部嵌套滚动子视图的情况，没有考虑自己作为滚动子视图的情况。</p>
<hr>
<p>如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882</p>
<p><img src="/arts/kotlin_group.jpg" alt=""></p>
</div><iframe src="/donate/?AliPayQR=/img/alipay.jpg&amp;WeChatQR=/img/wechat.jpg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/Android/">Android</a></div><div class="post-nav"><a class="pre" href="/2017/07/26/ViewDragHelper源码解析/">ViewDragHelper源码解析</a><a class="next" href="/2017/07/06/String、StringBuffer、StringBuilder的区别/">String、StringBuffer、StringBuilder的区别</a></div><div id="container"></div><link rel="stylesheet" href="/css/default.css?v=0.0.0"><script src="/js/gitment.browser.js?v=0.0.0"></script><script>var gitment = new Gitment({
  owner: 'itgoyo',
  repo: 'itgoyo.github.io',
  oauth: {
    client_id: '464e7c112346fd6daabb',
    client_secret: '3f78aa47b168a9788b888238a610dff1ac6e51ac',
  },
})
gitment.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://github.com/itgoyo"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习资料/">学习资料</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/源码分析/">源码分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/马克飞象/" style="font-size: 15px;">马克飞象</a> <a href="/tags/帮助/" style="font-size: 15px;">帮助</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/vim/" style="font-size: 15px;">vim</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/08/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/08/yml备份/">yml备份</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/08/欢迎使用马克飞象/">欢迎使用马克飞象</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/08/Vim常用快捷键大全/">Vim常用快捷键大全</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/08/linux中rime输入法安装使用小结/">linux中rime输入法安装使用小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/08/Android系统源码分析团体项目BeesAndroid正式上线啦 - 掘金/">Android系统源码分析团体项目BeesAndroid正式上线啦 - 掘金</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/08/传智播客——Android开发（一）拨打电话程序 - 充满生活的味道！ - BlogJava/">传智播客——Android开发（一）拨打电话程序 - 充满生活的味道！ - BlogJava</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/08/在GitHub上用Evernote+Hexo搭建个人静态博客/">在GitHub上用Evernote+Hexo搭建个人静态博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/01/不是吧/">不是吧</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/01/AAA.md/">AAA.md</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><p align="center">
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</p><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">itgoyo技术栈.</a> 作者Github:<a rel="nofollow" target="_blank" href="https://github.com/itgoyo"> itgoyo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
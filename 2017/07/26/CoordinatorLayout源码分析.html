<!DOCTYPE html>
<html>
<head>

    

    

    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?true"></script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    
    
    <title>CoordinatorLayout源码分析 | KotlinAndroid | 一个专注发布KotlinAndroid相关资源与优秀文章的技术网站</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    
    <meta name="keywords" content="Android">
    <meta name="description" content="项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 CoordinatorLayout 源码分析CoordinatorLayout有一些很有意思的特性，设置anchor、NestedScroll配合Toolbar/TabLayout的显隐or伸缩、Fab的移动等。今">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="CoordinatorLayout源码分析">
<meta property="og:url" content="https://github.com/itgoyo/2017/07/26/CoordinatorLayout源码分析.html">
<meta property="og:site_name" content="KotlinAndroid">
<meta property="og:description" content="项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 CoordinatorLayout 源码分析CoordinatorLayout有一些很有意思的特性，设置anchor、NestedScroll配合Toolbar/TabLayout的显隐or伸缩、Fab的移动等。今">
<meta property="og:image" content="https://img.shields.io/github/stars/itgoyo/AndroidSource-Analysis.svg?style=social&label=Star">
<meta property="og:image" content="https://github.com/arts/kotlin_group.jpg">
<meta property="og:updated_time" content="2017-07-26T11:54:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CoordinatorLayout源码分析">
<meta name="twitter:description" content="项目地址： https://github.com/itgoyo/AndroidSource-Analysis 简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。 CoordinatorLayout 源码分析CoordinatorLayout有一些很有意思的特性，设置anchor、NestedScroll配合Toolbar/TabLayout的显隐or伸缩、Fab的移动等。今">
<meta name="twitter:image" content="https://img.shields.io/github/stars/itgoyo/AndroidSource-Analysis.svg?style=social&label=Star">
    
    <link rel="shortcut icon" href="/">
    <link rel="stylesheet" href="/css/style.css?v=1.5.2">
    <script>window.lazyScripts=[]</script>

    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c16d3c10c9ea6c6fe749d9926d52b0d6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" style="
    width: 300px;" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/)">
      <div class="brand" style="
          width: 300px;">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">itgoyo</h5>
          <a href="mailto:undefined" class="mail">
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col" style="
        width: 300px;">
      <ul class="nav">
        

      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=300 height=270 src="https://music.163.com/outchain/player?type=0&id=120897804&auto=1&height=430"></iframe>

        <div class="div_right_bottom" align="center">
          <img src="http://open.weixin.qq.com/qr/code/?username=kotlinandroid">
          微信公众号
          </div>

      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">CoordinatorLayout源码分析</div>
        
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">CoordinatorLayout源码分析</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-07-26T11:53:52.000Z" itemprop="datePublished" class="page-time">
  2017-07-26
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/源码分析/">源码分析</a></li></ul>

            
        </h5>
    </div>

    

</header>


<div class="container body-wrap">
    
<article id="post-CoordinatorLayout源码分析"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">CoordinatorLayout源码分析</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-07-26 19:53:52" datetime="2017-07-26T11:53:52.000Z"  itemprop="datePublished">2017-07-26</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/源码分析/">源码分析</a></li></ul>



            

            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p><img src="https://img.shields.io/github/stars/itgoyo/AndroidSource-Analysis.svg?style=social&amp;label=Star" alt=""></p>
<p>项目地址： <a href="https://github.com/itgoyo/AndroidSource-Analysis">https://github.com/itgoyo/AndroidSource-Analysis</a></p>
<p>简介： Android源码分析，让你更清楚的理解每一个组件的功能与用法。</p>
<h1 id="CoordinatorLayout-源码分析"><a href="#CoordinatorLayout-源码分析" class="headerlink" title="CoordinatorLayout 源码分析"></a>CoordinatorLayout 源码分析</h1><p><code>CoordinatorLayout</code>有一些很有意思的特性，设置anchor、NestedScroll配合Toolbar/TabLayout的显隐or伸缩、Fab的移动等。今天咱就来一探究竟！</p>
<h2 id="1-从LayoutParam开始"><a href="#1-从LayoutParam开始" class="headerlink" title="1. 从LayoutParam开始"></a>1. 从LayoutParam开始</h2><p> <code>CoordinatorLayout.LayoutParam</code>中有一些不太一样的属性和元素，在此先进行介绍。</p>
<h3 id="1-1-特殊属性"><a href="#1-1-特殊属性" class="headerlink" title="1.1 特殊属性"></a>1.1 特殊属性</h3><table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">对应xml属性</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>AndchorId</code></td>
<td style="text-align:left"><code>layout_anchor</code> &amp;<code>layout_anchorGravity</code></td>
<td style="text-align:left">布局时根据自身<code>gravity</code> 与 <code>layout_anchorGravity</code>放置在被anchor的View中</td>
</tr>
<tr>
<td style="text-align:left"><code>Behavior</code></td>
<td style="text-align:left"><code>layout_behavior</code></td>
<td style="text-align:left">辅助Coordinator对View进行layout、nestedScroll的处理</td>
</tr>
<tr>
<td style="text-align:left"><code>KeyLine</code></td>
<td style="text-align:left"><code>layout_keyline</code> &amp; <code>keylines</code></td>
<td style="text-align:left">给Coordinator设置了<code>keylines</code>（整数数组）后，可以为子View设置<code>layout_keyline=&quot;i&quot;</code>使其的水平位置根据对应<code>keylines[i]</code>进行layout。</td>
</tr>
<tr>
<td style="text-align:left"><code>LastChildRect</code></td>
<td style="text-align:left">无</td>
<td style="text-align:left">记录每一次Layout的位置，从而判断是否新的一帧改变了位置</td>
</tr>
</tbody>
</table>
<p>注：</p>
<p><code>keyline</code>是一个非常奇怪的属性，我在看源码时才第一次看到到这玩意，网上的资料也非常之少。分析下来，就是如果设置了keyline，那么gravity就会被无视，直接放置在对应的水平位置keyline上。CoordinatorLayout里面也没有其他的特性是根据keyline实现的，个人认为没卵用，本文对它的分析基本都会略过。</p>
<h3 id="1-2-依赖关系"><a href="#1-2-依赖关系" class="headerlink" title="1.2 依赖关系"></a>1.2 依赖关系</h3><p>假设此时有两个View: <strong>A</strong> 和<strong>B</strong>，那么有两种情况会导致依赖关系：</p>
<ul>
<li><strong>A</strong>的<code>anchor</code>是<strong>B</strong> ；</li>
<li><strong>A</strong>的<code>behavior</code>对<strong>B</strong>有依赖（比如<code>FloatingActionButton</code>依赖<code>SnackBar</code>)。</li>
</ul>
<p>依赖关系建立的前提是两个View在同一个<code>Coordinatorlayout</code>中。</p>
<p><code>CoordinatorLayout</code>中维护了一个<code>mDependencySortedChildren</code>列表，里面含有所有的子View，<strong>按依赖关系排序，被依赖者排在前面</strong>。我们可以看一下用来排序的<code>Comparator</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Comparator&lt;View&gt; mLayoutDependencyComparator = <span class="keyword">new</span> Comparator&lt;View&gt;() &#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(View lhs, View rhs)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (lhs == rhs) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((LayoutParams) lhs.getLayoutParams()).dependsOn(</div><div class="line">               CoordinatorLayout.<span class="keyword">this</span>, lhs, rhs)) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((LayoutParams) rhs.getLayoutParams()).dependsOn(</div><div class="line">               CoordinatorLayout.<span class="keyword">this</span>, rhs, lhs)) &#123;</div><div class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，在建立<code>mDependencySortedChildren</code>并排序完成之后（在measure的第一步处理完成），每次对子View的遍历<strong>都是通过它进行顺序遍历</strong>，保证了被依赖的View最先被处理。</p>
</blockquote>
<h3 id="1-3-Behavior"><a href="#1-3-Behavior" class="headerlink" title="1.3 Behavior"></a>1.3 Behavior</h3><p>在<code>CoordinatorLayout</code>中定义了<code>Behavior</code>类，它是用来辅助layout的工具。如果一个CoordinatorLayout的直接子View设置了<code>Behavior</code>（或者通过类注解<code>@DefaultBehavior</code>指定<code>Behavior</code>），则该Behavior会储存在该View的<code>LayoutParam</code>中。</p>
<blockquote>
<p>注意：不是CoordinatorLayout的直接子View，设置Behavior是无效的。你可以看到任何一处对于Behavior的处理都是直接<code>getChildCount（）</code>遍历。</p>
</blockquote>
<p>在Behavior中有几类功能，我们一一进行介绍：</p>
<h4 id="1-3-1-触摸响应类"><a href="#1-3-1-触摸响应类" class="headerlink" title="1.3.1 触摸响应类"></a>1.3.1 触摸响应类</h4><p><code>Behavior</code>中有两个函数：<code>onInterceptTouchEvent</code>、 <code>onTouchEvent</code>。在CoordinatorLayout每次触发对应事件的时候会选择一个最适合的子View的Behavior执行对应函数。我们来看一下CoordinatorLayout是怎么分发和处理Touch事件的：</p>
<p><strong><em>intercept</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">   MotionEvent cancelEvent = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</div><div class="line"></div><div class="line">   <span class="comment">// 重置响应的Behavoir</span></div><div class="line">   <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</div><div class="line">       resetTouchBehaviors();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">	<span class="comment">// 在这里选择一个最佳Behavior进行处理</span></div><div class="line">   <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted = performIntercept(ev, TYPE_ON_INTERCEPT);</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (cancelEvent != <span class="keyword">null</span>) &#123;</div><div class="line">       cancelEvent.recycle();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">	<span class="comment">// 重置响应的Behavior</span></div><div class="line">   <span class="keyword">if</span> (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) &#123;</div><div class="line">       resetTouchBehaviors();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> intercepted;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>performIntercept</code>去选择一个最适合的Behavior来进行处理，这个方法不仅用于<code>onInterceptTouchEvent</code>，并且也用于<code>onTouchEvent</code>，根据传入<code>type</code>不同来识别对应方法。我们来看看它的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performIntercept</span><span class="params">(MotionEvent ev, <span class="keyword">final</span> <span class="keyword">int</span> type)</span> </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</div><div class="line">   <span class="keyword">boolean</span> newBlock = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">   MotionEvent cancelEvent = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</div><div class="line"></div><div class="line">   <span class="keyword">final</span> List&lt;View&gt; topmostChildList = mTempList1;</div><div class="line"></div><div class="line">   <span class="comment">// API&gt;=21时，使用elevation由低到高排列View；API&lt;21时，按View添加顺序排列</span></div><div class="line">   getTopSortedChildren(topmostChildList);</div><div class="line"></div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> childCount = topmostChildList.size();</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i) &#123;</div><div class="line">       <span class="keyword">final</span> View child = topmostChildList.get(i);</div><div class="line">       <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line">       <span class="keyword">final</span> Behavior b = lp.getBehavior();</div><div class="line"></div><div class="line">       <span class="comment">// ...(省略代码) 如果此次判定intercept，则对上次的Behavior发送CANCEL事件。</span></div><div class="line"></div><div class="line">		<span class="comment">// 根据传入type不同调用不同的方法</span></div><div class="line">       <span class="keyword">if</span> (!intercepted &amp;&amp; b != <span class="keyword">null</span>) &#123;</div><div class="line">           <span class="keyword">switch</span> (type) &#123;</div><div class="line">               <span class="keyword">case</span> TYPE_ON_INTERCEPT:</div><div class="line">                   intercepted = b.onInterceptTouchEvent(<span class="keyword">this</span>, child, ev);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               <span class="keyword">case</span> TYPE_ON_TOUCH:</div><div class="line">                   intercepted = b.onTouchEvent(<span class="keyword">this</span>, child, ev);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span> (intercepted) &#123;</div><div class="line">               mBehaviorTouchView = child;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">		<span class="comment">//...(省略代码) 如果Behavior.blocksInteractionBelow()返回true，则不处理后续的事件。</span></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   topmostChildList.clear();</div><div class="line"></div><div class="line">   <span class="keyword">return</span> intercepted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-3-2-依赖关系类"><a href="#1-3-2-依赖关系类" class="headerlink" title="1.3.2 依赖关系类"></a>1.3.2 依赖关系类</h4><p> 这部分比较简单，就俩函数：<br>   <code>layoutDependsOn</code>：返回<code>true</code>则表示对另一个View有依赖关系；<br>   <code>onDependentViewChanged</code>&amp;<code>onDependentViewRemoved</code>：如果被依赖的View在正常layout之后仍有size/position上的变化，或者被remove掉，都会触发对应方法。</p>
<p> 那么问题来了，CoordinatorLayout是怎么监听这个被依赖的View改变的事件的呢？</p>
<p> 原来它里面有一个<code>ViewTreeObserver.OnPreDrawListener</code>，它在<code>onMeasure</code>的时候被添加到了<code>ViewTreeObserver</code>中，这样每一帧被绘制出来之前都会调用这个回调。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnPreDrawListener</span> <span class="keyword">implements</span> <span class="title">ViewTreeObserver</span>.<span class="title">OnPreDrawListener</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onPreDraw</span><span class="params">()</span> </span>&#123;</div><div class="line">        dispatchOnDependentViewChanged(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这个<code>dispatchOnDependentViewChanged</code>里面代码比较多，就不放上来了，总结下来就是这样：</p>
<p> 根据依赖关系遍历子View，对每一个View做如下操作</p>
<ul>
<li>判断一下新的布局边界与lastChildRect是否相同，是则记录新的布局边界为lastChildRect，并继续后续流程，否则跳过；</li>
<li><p>对于之后每一个View，如果它依赖于本View，则调用它的<code>Behavior.onDependentViewChanged</code>（如果有Behavior的话）。</p>
<p>至于<code>onDependentViewRemoved</code>，是在初始化的时候就会调用<code>ViewGroup.setOnHierarchyChangeListener()</code>方法设置一个<code>OnHierarchyChangeListener</code>，这样每次add和remove子View的时候就会接收到回调，同时对相应依赖关系的View进行处理。</p>
</li>
</ul>
<h4 id="1-3-3-布局类"><a href="#1-3-3-布局类" class="headerlink" title="1.3.3 布局类"></a>1.3.3 布局类</h4><p><code>onMeasureChild</code>&amp;<code>onLayoutChild</code>：如果重写了该方法并返回<code>true</code>，则CoordinatorLayout会使用Behavior对这个子View进行measure/layout。具体的可以见下面的<strong>Measure&amp;Layout</strong></p>
<h4 id="1-3-4-嵌套滑动类"><a href="#1-3-4-嵌套滑动类" class="headerlink" title="1.3.4 嵌套滑动类"></a>1.3.4 嵌套滑动类</h4><p>CoordinatorLayout实现了<code>NestedScrollingParent</code>，当CoordinatorLayout内有一个支持NestedScroll的子View时，它的嵌套滑动事件通过<code>NestedScrollingParent</code>的回调分发到各直接子View的Behavior处理。虽然<code>Behavior</code>类没有实现<code>NestedScrollingParent</code>，但是实际上它的方法都有。有兴趣的同学可以去看看这个类，我们这里重点讲CoordinatorLayout的分发过程。</p>
<p> 各个事件的分发过程类似，此处就举一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</div><div class="line">     <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">     <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i) &#123;</div><div class="line">         <span class="keyword">final</span> View view = getChildAt(i);</div><div class="line">         <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</div><div class="line">         <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</div><div class="line">         <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</div><div class="line">             <span class="keyword">final</span> <span class="keyword">boolean</span> accepted = viewBehavior.onStartNestedScroll(<span class="keyword">this</span>, view, child, target,</div><div class="line">                     nestedScrollAxes);</div><div class="line">             handled |= accepted;</div><div class="line"></div><div class="line">             lp.acceptNestedScroll(accepted);</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">             lp.acceptNestedScroll(<span class="keyword">false</span>);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> handled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>非常简单吧，就遍历一下直接子View，每个都调一下对应的回调方法，只要有任何一个子View的behavior消耗了这个事件，就算消耗了这个事件。</p>
<p>##2. Measure&amp;Layout</p>
<p>我们知道，ViewGroup要把子View准确地放置到屏幕上都是要走<code>onMeasure</code>  <code>onLayout</code>的，那么我们看看<code>CoordinatorLayout</code>在这里干了什么。</p>
<p>在看懂时请确保你明白<code>measure/layout</code>的意义以及基本用法，否则可能会导致身体不适=。=</p>
<h3 id="2-1-Measure"><a href="#2-1-Measure" class="headerlink" title="2.1 Measure"></a>2.1 Measure</h3><p>最直接的就是看代码，如果不喜欢，可以跳过代码看总结。：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</div><div class="line">   prepareChildren(); <span class="comment">/* 解析依赖关系，并用1.2中提到的Comparator对View按依赖关系进行排序 */</span></div><div class="line">   ensurePreDrawListener(); <span class="comment">/* 若PreDrawListener未添加，则添加到ViewTreeObserver */</span></div><div class="line"></div><div class="line">   <span class="comment">//...(省略代码) 解析paddingmeasureSpec</span></div><div class="line"></div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> childCount = mDependencySortedChildren.size();</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i) &#123;</div><div class="line">       <span class="keyword">final</span> View child = mDependencySortedChildren.get(i);</div><div class="line">       <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">		<span class="comment">//...(省略代码)处理keyline</span></div><div class="line"></div><div class="line">       <span class="keyword">int</span> childWidthMeasureSpec = widthMeasureSpec;</div><div class="line">       <span class="keyword">int</span> childHeightMeasureSpec = heightMeasureSpec;</div><div class="line"></div><div class="line">		<span class="comment">//...(省略代码) 处理由于fitSystemWindows带来的padding</span></div><div class="line"></div><div class="line">		<span class="comment">/* 如果childView有Behavior并且它的onMeasureChild返回true，则由behavior来对childView进行measure，否则就自己measure. */</span></div><div class="line">       <span class="keyword">final</span> Behavior b = lp.getBehavior();</div><div class="line">       <span class="keyword">if</span> (b == <span class="keyword">null</span> || !b.onMeasureChild(<span class="keyword">this</span>, child, childWidthMeasureSpec, keylineWidthUsed,</div><div class="line">               childHeightMeasureSpec, <span class="number">0</span>)) &#123;</div><div class="line">           onMeasureChild(child, childWidthMeasureSpec, keylineWidthUsed,</div><div class="line">                   childHeightMeasureSpec, <span class="number">0</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">		<span class="comment">/* 取最大的child width/height 加上margin 作为已经消耗的尺寸。 */</span></div><div class="line">       widthUsed = Math.max(widthUsed, widthPadding  child.getMeasuredWidth()</div><div class="line">               lp.leftMargin  lp.rightMargin);</div><div class="line">       heightUsed = Math.max(heightUsed, heightPadding  child.getMeasuredHeight()</div><div class="line">               lp.topMargin  lp.bottomMargin);</div><div class="line"></div><div class="line">       childState = ViewCompat.combineMeasuredStates(childState,</div><div class="line">               ViewCompat.getMeasuredState(child));</div><div class="line">   &#125;</div><div class="line"></div><div class="line">	<span class="comment">/* 设置自身的measure尺寸 */</span></div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> width = ViewCompat.resolveSizeAndState(widthUsed, widthMeasureSpec,</div><div class="line">           childState &amp; ViewCompat.MEASURED_STATE_MASK);</div><div class="line">   <span class="keyword">final</span> <span class="keyword">int</span> height = ViewCompat.resolveSizeAndState(heightUsed, heightMeasureSpec,</div><div class="line">           childState &lt;&lt; ViewCompat.MEASURED_HEIGHT_STATE_SHIFT);</div><div class="line">   setMeasuredDimension(width, height);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结下来，onMeasure干了这么几件事：</p>
<ol>
<li>根据依赖关系对所有子View进行排序</li>
<li>保证OnPreDrawListener被添加</li>
<li>按依赖关系遍历子View:<ul>
<li>如果子View有Behavior，并且它的<code>onMeasureChild</code>返回true，则使用Behavior进行measure；否则直接使用measureSpec对子View进行measure；</li>
<li>取子VIew最大的measure尺寸为已使用的measure尺寸。</li>
</ul>
</li>
<li>更新本身的Measure尺寸。</li>
</ol>
<h3 id="2-2-Layout"><a href="#2-2-Layout" class="headerlink" title="2.2 Layout"></a>2.2 Layout</h3><p> 在<code>onLayout</code>中，我们可以看到<code>CoordinatorLayout</code>会对每一个子View依照以下判断顺序进行layout：</p>
<ol>
<li>如果子View设置了<code>Behavior</code>，并且该<code>Behavior</code>的<code>behavior.onLayoutChild</code>返回<code>true</code>，则使用<code>behavior.onLayoutChild</code>对该子View进行layout；</li>
<li><p>如果Behavior不进行layout，则进入自身的<code>onLayoutChild()</code>，内部依次进行如下判断：</p>
<ul>
<li>如果子View设置了<code>Anchor</code>，则调用<code>layoutChildWithAnchor</code>（根据anchor进行layout）；</li>
<li>如果子View含有<code>keyline</code>，则调用<code>layoutChildWithKeyline</code>（根据keyline进行layout）；</li>
<li>如果以上判断都不符合，则直接将View根据<strong>padding/margin/measure结果</strong>按照<code>Gravity</code>放置。</li>
</ul>
<p>我们一一来看一下这些过程。</p>
</li>
</ol>
<h4 id="2-2-1-使用Behavior进行layout"><a href="#2-2-1-使用Behavior进行layout" class="headerlink" title="2.2.1 使用Behavior进行layout"></a>2.2.1 使用Behavior进行layout</h4><p> 默认的Behavior的<code>onLayoutChild</code>都是返回<code>false</code>的，那么我们看看<code>FloatingActionButton</code>的默认Behavior是怎么处理的吧：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onLayoutChild</span><span class="params">(CoordinatorLayout parent, FloatingActionButton child,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">int</span> layoutDirection)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 检查该FAB是否依赖AppBarLayout</span></div><div class="line">    <span class="keyword">final</span> List&lt;View&gt; dependencies = parent.getDependencies(child);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = dependencies.size(); i &lt; count; i) &#123;</div><div class="line">        <span class="keyword">final</span> View dependency = dependencies.get(i);</div><div class="line">        <span class="keyword">if</span> (dependency <span class="keyword">instanceof</span> AppBarLayout</div><div class="line">                &amp;&amp; updateFabVisibility(parent, (AppBarLayout) dependency, child)) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 调用CoordinatorLayout的onLayoutChild对FAB进行layout</span></div><div class="line">    parent.onLayoutChild(child, layoutDirection);</div><div class="line">    <span class="comment">// 在API &lt; 21时，需要手动offset来让出阴影的位置</span></div><div class="line">    offsetIfNeeded(parent, child);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要是处理了如果FAB设置了<code>AppBarLayout</code>为anchor时（此时会对<code>AppBarLayout</code>有依赖），则当<code>AppBarLayout</code>的高度不足以显示FAB时将其隐藏）。</p>
<p>之后它会手动调用CoordinatorLayout自身的<code>onLayoutChild</code>方法进行layout，即上述判断的第二步，那我们继续往下看。</p>
<h4 id="2-2-2-使用Anchor进行layout"><a href="#2-2-2-使用Anchor进行layout" class="headerlink" title="2.2.2 使用Anchor进行layout"></a>2.2.2 使用Anchor进行layout</h4><p> 如果View设置了anchor，那么都会调用<code>layoutWithAnchor</code>进行layout，代码与解释如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">layoutChildWithAnchor</span><span class="params">(View child, View anchor, <span class="keyword">int</span> layoutDirection)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Rect anchorRect = mTempRect1;</div><div class="line">    <span class="keyword">final</span> Rect childRect = mTempRect2;</div><div class="line"></div><div class="line">    <span class="comment">/* 1. 找到被anchor的View的布局边界 */</span></div><div class="line">    getDescendantRect(anchor, anchorRect);</div><div class="line"></div><div class="line">    <span class="comment">/* 2. 获取到被anchor的View布局边界之后，配合layout_anchorGravity与自身的gravity获取到最终要layout到的边界 */</span></div><div class="line">    getDesiredAnchoredChildRect(child, layoutDirection, anchorRect, childRect);</div><div class="line">    child.layout(childRect.left, childRect.top, childRect.right, childRect.bottom);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里用到的两个关键函数就是<code>getDescendantRect</code>与<code>getDesiredAnchoredChildRect</code>，它们的目的在我添加的注释中进行了解释，为保证文章的可读性就不再把代码放上来了，有兴趣的同学可以再自己去挖掘相应代码~~</p>
<h4 id="2-2-3-直接layout"><a href="#2-2-3-直接layout" class="headerlink" title="2.2.3 直接layout"></a>2.2.3 直接layout</h4><p>如果之前的都不符合，就会走到这一步，我们看看它是怎么layout的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">layoutChild</span><span class="params">(View child, <span class="keyword">int</span> layoutDirection)</span> </span>&#123;</div><div class="line">      <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</div><div class="line">      <span class="keyword">final</span> Rect parent = mTempRect1;</div><div class="line">      parent.set(getPaddingLeft()  lp.leftMargin,</div><div class="line">              getPaddingTop()  lp.topMargin,</div><div class="line">              getWidth() - getPaddingRight() - lp.rightMargin,</div><div class="line">              getHeight() - getPaddingBottom() - lp.bottomMargin);</div><div class="line"></div><div class="line">      <span class="comment">//...(省略代码) 处理由于fitsSystemWindows带来的inset</span></div><div class="line"></div><div class="line"> 	 <span class="comment">// 按照Gravity与measure尺寸在父控件里面找到自己的位置，并进行layout。</span></div><div class="line">      <span class="keyword">final</span> Rect out = mTempRect2;</div><div class="line">      GravityCompat.apply(resolveGravity(lp.gravity), child.getMeasuredWidth(),</div><div class="line">              child.getMeasuredHeight(), parent, out, layoutDirection);</div><div class="line">      child.layout(out.left, out.top, out.right, out.bottom);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>##3 总结</p>
<p>CoordinatorLayout的特性总结下来就是两个方面：</p>
<ol>
<li>可以设置anchor，被依赖的View变化自身也会变化；</li>
<li>可以设置behavior，当内部有支持嵌套滑动的控件时处理NestedScroll事件；</li>
</ol>
<p>这两个特性导致的子View之间的依赖关系让界面的交互更有意思。有兴趣的同学可以再去看<code>AppBarLayout</code>、<code>FloatingActionButton</code>、<code>SnackBar</code>的源码~~</p>
<hr>
<p>如果你有兴趣加入我们，请直接关注公众号 Kotlinandroid ，或者加 QQ 群：465280882</p>
<p><img src="/arts/kotlin_group.jpg" alt=""></p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        

        
    </div>
    <footer>
        <a href="https://github.com/itgoyo">
            <img src="/" alt="itgoyo">
            itgoyo
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>


            


        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/07/26/FloatingActionButton源码解析.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">FloatingActionButton源码解析</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/07/26/CompoundButton源码分析.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">CompoundButton源码分析</h4>
      </a>
    </div>
  
</nav>



    


<section class="comments" id="comments">
    <div id="disqus_thread"></div>
    <script>
    var disqus_shortname = 'itgoyo';
    lazyScripts.push('//' + disqus_shortname + '.disqus.com/embed.js')
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>













</article>



</div>

        <footer class="footer">

    <div class="bottom">
  

        <p>
            <span>itgoyo &copy; 2017</span>  &nbsp&nbsp&nbsp 作者Github地址 欢迎关注 <a href="https://github.com/itgoyo" target="_blank">itgoyo</a>
              <a href="" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a>
        </p>
        <p>
        感谢西部数码提供<a href="http://www.west.cn/index.asp?ReferenceID=1232730"
        target="_blank">虚拟主机</a>
        </p>
        <p>
            <span>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: , REWARD: false };



</script>

<script src="/js/main.min.js?v=1.5.2"></script>









</body>
</html>
